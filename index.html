<!DOCTYPE html>
<html lang="de">
    <!--
    * @author Daniel Groß
    * @copyright // Last modified: 2025/03/20 10:02:32
    -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>tima</title>
    <link rel="icon" href="assets/icon.svg" type="image/svg+xml">
    <link rel="manifest" href="assets/website.manifest" crossorigin="use-credentials">
    <link rel="stylesheet" href="assets/style.css">
    <script src="assets/beep.js"><!-- github.com/luciferous/beepjs/blob/master/beep.js --></script>
</head>

<style>
@font-face {
    font-display: swap;
    font-family: "Nunito-Digits";
    font-style: normal;
    font-weight: 400;
    src: url("assets/Nunito-Regular-Subset.woff2") format("woff2");
}
</style>

<body>
    <div class="theme-toggle">
        <input type="checkbox" id="theme-toggle-checkbox" aria-label="Theme wechseln">
        <label for="theme-toggle-checkbox" class="theme-toggle-label">
            <svg class="theme-toggle-icon" viewBox="0 0 24 24" width="24" height="24" stroke-linecap="round">
                <path class="moon" d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1-8.313-12.454z" />
                <g class="sun" stroke="#999" stroke-width="2">
                    <circle cx="12" cy="12" r="5" fill="none" />
                    <line x1="12" y1="2" x2="12" y2="4" />
                    <line x1="12" y1="20" x2="12" y2="22" />
                    <line x1="2" y1="12" x2="4" y2="12" />
                    <line x1="20" y1="12" x2="22" y2="12" />
                    <line x1="5.64" y1="5.64" x2="4.22" y2="4.22" />
                    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78" />
                    <line x1="5.64" y1="18.36" x2="4.22" y2="19.78" />
                    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22" />
                </g>
            </svg>
        </label>
    </div>
    <div class="progress-circle" id="progress-circle" role="progressbar">
        <svg viewBox="0 0 400 400" stroke-width="13" fill="none" stroke-linecap="round">
            <circle class="outercircle" id="progress-outercircle" cx="200" cy="200" r="185.5" transform="rotate(3 200 200)" />
            <circle class="innercircle" id="progress-innercircle" cx="200" cy="200" r="185.5" transform="rotate(-91 200 200)" />
        </svg>
        <div class="text" id="progress-text">60</div>
    </div>
    
    <div class="reset-timer" id="reset-timer">
        <div class="reset-timer-button" id="reset-timer-button" role="button" aria-label="Timer zurücksetzen">
            <svg class="reset-timer-icon" viewBox="0 0 24 24" fill="none" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="4.2,4.6 4.2,8.6 8.2,8.6" />
                <path d="M11.6,7.8v4.9h4.5" />
                <path d="M5,8c1.4-2.4,4-4,6.9-4	c4.4,0,8,3.6,8,8s-3.6,8-8,8s-8-3.6-8-8" />
            </svg>
        </div>
    </div>

    <div class="elapsed-time" id="elapsed-time">00:00</div>
    <div class="settings-button" id="settings-button" role="button" aria-label="Einstellungen öffnen">…</div>
    <div class="settings-dialog" id="settings-dialog" role="dialog" aria-labelledby="settings-dialog-title">
        <span class="close-button" id="close-button" role="button" aria-label="Einstellungen schließen">&times;</span>
        <p id="settings-dialog-title">Einstellungen</p>
        <label for="beep-times">Beep Zeiten (Sekunden, durch Kommas getrennt):</label>
        <input type="text" id="beep-times" value="45,30,15,3,2,1,0">
        <label for="timer-duration">Dauer des Countdown-Timers (Sekunden):</label>
        <input type="number" id="timer-duration" value="60">
    </div>

    <script>
        (function () {
        const progresscircle = document.getElementById('progress-circle');
        const progressText = document.getElementById('progress-text');
        const progressPath = document.getElementById('progress-innercircle');
        const progressOuterPath = document.getElementById('progress-outercircle');
        const elapsedTimeDisplay = document.getElementById('elapsed-time');
        const settingsButton = document.getElementById('settings-button');
        const settingsDialog = document.getElementById('settings-dialog');
        const closeButton = document.getElementById('close-button');
        const beepTimesInput = document.getElementById('beep-times');
        const timerDurationInput = document.getElementById('timer-duration');
        const resetTimer = document.getElementById('reset-timer');
        const toggleCheckbox = document.getElementById('theme-toggle-checkbox');
        let beep;

        function createFallbackBeep() {
            const beepsound = new Beep(22050).encode(650, 0.06, [Beep.utils.amplify(8000)]);
            return new Audio('data:audio/x-wav;base64,' + btoa(beepsound));
        }

        try {
            beep = new Audio("assets/blip-131856.mp3");
            beep.addEventListener('error', () => {
                beep = createFallbackBeep();
            });
        } catch (e) {
            beep = createFallbackBeep();
        }
                
        let beepTimes = [45, 30, 15, 3, 2, 1, 0];
        const timerDurationPreset = 60;
        let timerDuration = timerDurationPreset;
        const timerDevider = 10;
        let timeLeft = timerDuration * timerDevider;
        let elapsedTime = 0;
        let countdown;
        let running = false;
        const totalLength = 1165;
        const gap = 19;

        function setCookie(name, value, days) {
            if (window.localStorage) {
                window.localStorage.setItem(name, value);
            } else {
                const d = new Date();
                d.setTime(d.getTime() + (days * 24 * 60 * 60 * 1000));
                const expires = "expires=" + d.toUTCString();
                document.cookie = name + "=" + value + ";" + expires + ";path=/";
            }
        }

        function getCookie(name) {
            if (window.localStorage) {
                return window.localStorage.getItem(name);
            } else {
                const cname = name + "=";
                const decodedCookie = decodeURIComponent(document.cookie);
                const ca = decodedCookie.split(';');
                for (let i = 0; i < ca.length; i++) {
                    let c = ca[i];
                    while (c.charAt(0) === ' ') {
                        c = c.substring(1);
                    }
                    if (c.indexOf(cname) === 0) {
                        return c.substring(cname.length, c.length);
                    }
                }
                return "";
            }
        }

        function sanitizebeepTimesInput(input) {
            return input
                .split(',')
                .map(n => Number(n.trim()))
                .filter(n => !isNaN(n) && n <= timerDuration)
                .sort((a, b) => b - a);
        }

        function loadSettings() {
            const timerDurationCookie = getCookie("timerDuration");
            if (timerDurationCookie) {
                const newValue = Number(timerDurationCookie);
                timerDuration = (newValue <= 0 || isNaN(newValue)) ? timerDurationPreset : newValue;
                timerDurationInput.value = timerDuration;
                timeLeft = timerDuration * timerDevider;
                progressText.innerText = timerDuration;
            }
            const savedTheme = getCookie('theme');
            if (savedTheme) {
                document.body.classList.add(savedTheme);
                toggleCheckbox.checked = savedTheme === 'light-mode';
            }
            const beepTimesCookie = getCookie("beepTimes");
            if (beepTimesCookie) {
                beepTimes = sanitizebeepTimesInput(beepTimesCookie);
                beepTimesInput.value = beepTimes.join(',');
            }
            calculateBeepGaps();
        }

        function calculateBeepGaps() {
            const beepTimesTemp = [timerDuration, ...beepTimes, 0];

            const dashArray = beepTimesTemp
                .map((time, i, arr) => i < arr.length - 1 ? time - arr[i + 1] : null)
                .filter(interval => interval > 0)
                .map((interval, i, arr) => {
                    const calculatedGap = i === arr.length - 1 ? 0 : gap;
                    return `${(interval / timerDuration) * totalLength - calculatedGap} ${calculatedGap}`;
                })
                .join(' ');

            progressOuterPath.style.strokeDasharray = dashArray;
        }

        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}`;
        }

        settingsButton.addEventListener('click', () => {
            settingsDialog.style.display = settingsDialog.style.display === 'block' ? 'none' : 'block';
        });

        closeButton.addEventListener('click', () => {
            settingsDialog.style.display = 'none';
        });

        beepTimesInput.addEventListener('change', () => {
            beepTimes = sanitizebeepTimesInput(beepTimesInput.value);
            calculateBeepGaps();
            setCookie("beepTimes", beepTimes.join(','), 365);
            beepTimesInput.value = beepTimes.join(',');
        });

        timerDurationInput.addEventListener('change', () => {
            const newValue = Number(timerDurationInput.value);
            timerDuration = (newValue <= 0 || isNaN(newValue)) ? timerDurationPreset : newValue;
            setCookie("timerDuration", timerDuration, 365);
            timeLeft = timerDuration * timerDevider;
            progressText.innerText = timerDuration;
            timerDurationInput.value = timerDuration;
            calculateBeepGaps();
        });

        progresscircle.addEventListener('click', () => {
            if (!running) {
                running = true;
                countdown = setInterval(() => {
                    timeLeft--;
                    elapsedTime++;
                    const timeLeft_in_seconds = Math.floor(timeLeft / timerDevider);
                    progressPath.style.strokeDashoffset = (timeLeft / (timerDuration * timerDevider)) * totalLength;
                    progressPath.style.transition = timeLeft > (timerDuration * timerDevider - 2) ? 'none' : 'stroke-dashoffset 0.1s linear';
                    if (timeLeft % timerDevider === 0) {
                        progressText.innerText = timeLeft === 0 ? timerDuration : timeLeft_in_seconds;
                        elapsedTimeDisplay.innerText = formatTime(Math.floor(elapsedTime / timerDevider));
                        if (beepTimes.includes(timeLeft_in_seconds)) {
                            beep.play();
                        }
                    }
                    if (timeLeft <= 0) {
                        timeLeft = timerDuration * timerDevider;
                    }
                    resetTimer.style.display = elapsedTime > 0 ? 'flex' : 'none';
                }, 1000 / timerDevider);
            } else {
                clearInterval(countdown);
                running = false;
            }
        });

        document.addEventListener('DOMContentLoaded', function () {
            const body = document.body;
            const savedTheme = getCookie('theme');
            if (savedTheme) {
                body.classList.add(savedTheme);
                toggleCheckbox.checked = savedTheme === 'light-mode';
            }

            toggleCheckbox.addEventListener('change', function () {
                body.classList.toggle('light-mode', this.checked);
                body.classList.toggle('dark-mode', !this.checked);
                setCookie('theme', this.checked ? 'light-mode' : 'dark-mode', 365);
            });

            const resetTimerButton = document.getElementById('reset-timer-button');
            resetTimerButton.addEventListener('click', () => {
                clearInterval(countdown);
                running = false;
                timeLeft = timerDuration * timerDevider;
                elapsedTime = 0;
                progressText.innerText = timerDuration;
                progressPath.style.strokeDashoffset = totalLength;
                elapsedTimeDisplay.innerText = formatTime(0);
                resetTimer.style.display = 'none';
            });
        });

        loadSettings();
    })();
    </script>
</body>

</html>